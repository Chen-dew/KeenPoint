"""Dify Workflow API 客户端模块"""

from __future__ import annotations

import json
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

import requests

from app.core.config import settings
from app.core.logger import logger


# MIME类型映射表
MIME_TYPES = {
    'png': 'image/png',
    'jpg': 'image/jpeg',
    'jpeg': 'image/jpeg',
    'webp': 'image/webp',
    'gif': 'image/gif',
    'txt': 'text/plain',
    'md': 'text/markdown',
    'pdf': 'application/pdf',
    'doc': 'application/msword',
    'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
}


class DifyWorkflowClient:
    """Dify Workflow API 客户端"""

    def __init__(
        self,
        api_key: str,
        base_url: Optional[str] = None,
        default_user: str = "chen"
    ) -> None:
        """初始化客户端"""
        if not api_key:
            raise ValueError("api_key is required")

        self.api_key = api_key
        self.base_url = (base_url or settings.DIFY_API_BASE_URL).rstrip("/")
        self.default_user = default_user
        self.run_url = f"{self.base_url}/workflows/run"
        self.upload_url = f"{self.base_url}/files/upload"

	def upload_files(
		self,
		file_paths: List[Union[str, Path]],
		user: Optional[str] = None,
		continue_on_error: bool = True
	) -> List[Dict[str, Any]]:
		"""
		批量上传文件到 Dify
		
		Args:
			file_paths: 文件路径列表
			user: 用户标识
			continue_on_error: 遇到错误时是否继续
			
		Returns:
			上传结果列表，包含 file_id
		"""
		if not file_paths:
			logger.warning("upload_files file_paths_empty")
			return []
		
		if not isinstance(file_paths, list):
			file_paths = [file_paths]
		
		logger.info(f"upload_files start count={len(file_paths)}")
		results = []
		user_id = user or self.default_user
		
		for idx, file_path in enumerate(file_paths, 1):
			file_path = Path(file_path)
			
			try:
				if not file_path.exists():
					raise FileNotFoundError(f"文件不存在: {file_path}")
				
				# 获取文件类型
				file_ext = file_path.suffix.lower().lstrip('.')
				mime_type = self._get_mime_type(file_ext)
				
				# 执行上传
				headers = {'Authorization': f'Bearer {self.api_key}'}
				with open(file_path, 'rb') as f:
					files = {'file': (file_path.name, f, mime_type)}
					data = {'user': user_id}
					
					response = requests.post(
						self.upload_url,
						headers=headers,
						files=files,
						data=data,
						timeout=300
					)
					response.raise_for_status()
					result = response.json()
				
				results.append({
					'success': True,
					'file_path': str(file_path),
					'file_id': result.get('id'),
					'file_name': result.get('name'),
					'data': result
				})
				logger.info(f"upload_files success idx={idx}/{len(file_paths)} file={file_path.name} file_id={result.get('id')}")
				
			except Exception as e:
				error_info = {
					'success': False,
					'file_path': str(file_path),
					'error': str(e)
				}
				results.append(error_info)
				logger.error(f"upload_files failed idx={idx}/{len(file_paths)} file={file_path.name} error={str(e)}")
				
				if not continue_on_error:
					logger.error("upload_files interrupted")
					break
		
		success_count = sum(1 for r in results if r.get('success'))
		logger.info(f"upload_files done success={success_count}/{len(file_paths)}")
		return results
	
	def _get_mime_type(self, file_ext: str) -> str:
		"""获取文件MIME类型"""
		mime_types = {
			'png': 'image/png',
			'jpg': 'image/jpeg',
			'jpeg': 'image/jpeg',
			'webp': 'image/webp',
			'gif': 'image/gif',
			'txt': 'text/plain',
			'md': 'text/markdown',
			'pdf': 'application/pdf',
			'doc': 'application/msword',
			'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
		}
		
		mime_type = mime_types.get(file_ext)
		if not mime_type:
			raise ValueError(f"不支持的文件类型: {file_ext}")
		return mime_type


	def run_workflow(
		self,
		llm_id: int,
		user_prompt: str,
		user: Optional[str] = None,
		extra_inputs: Optional[Dict[str, Any]] = None,
		timeout: int = 300,
		response_mode: str = "blocking",
	) -> Dict[str, Any]:
		"""
		调用 /v1/workflows/run（阻塞模式，直接返回结果）。

		Returns:
			完整的响应结果字典
		"""
		if not isinstance(llm_id, int):
			raise ValueError("llm_id must be an integer")
		if not isinstance(user_prompt, str) or not user_prompt.strip():
			raise ValueError("user_prompt must be a non-empty string")

		payload_inputs: Dict[str, Any] = {"llm_id": llm_id, "user_prompt": user_prompt}
		if extra_inputs:
			payload_inputs.update(extra_inputs)

		payload = {
			"inputs": payload_inputs,
			"response_mode": response_mode,
			"user": user or self.default_user,
		}

		headers = {
			"Authorization": f"Bearer {self.api_key}",
			"Content-Type": "application/json",
		}

		logger.info(
			"dify_workflow_run start url=%s mode=%s user=%s",
			self.run_url,
			response_mode,
			payload["user"],
		)

		try:
			resp = requests.post(
				self.run_url,
				headers=headers,
				json=payload,
				stream=False,
				timeout=timeout,
			)
			resp.raise_for_status()
			
			# 阻塞模式：直接返回 JSON
			result = resp.json()
			logger.info(
				"dify_workflow_run done status=%s",
				result.get("data", {}).get("status", "unknown")
			)
			return result

		except requests.exceptions.RequestException as e:
			logger.error("dify_workflow_run request_error error=%s", str(e))
			raise
		except Exception as e:
			logger.error("dify_workflow_run error=%s", str(e))
			raise


def get_workflow_client(api_key: Optional[str] = None, user: Optional[str] = None) -> DifyWorkflowClient:
    """
    获取/创建 DifyWorkflowClient。
    - api_key 为空时，使用 settings.DIFY_WORKFLOW_API_KEY（如需专用 key 可显式传入）。
    - user 为空时，使用 settings.DIFY_WORKFLOW_USER。
    """
    key = api_key or settings.DIFY_WORKFLOW_API_KEY
    if not key:
        raise ValueError("DIFY_WORKFLOW_API_KEY 未配置")
    return DifyWorkflowClient(
        api_key=key,
        base_url=settings.DIFY_API_BASE_URL,
        default_user=user or settings.DIFY_WORKFLOW_USER
    )


def analyze_summary(
	user_prompt: str,
	llm_id: int = 1,
	user: Optional[str] = None,
	extra_inputs: Optional[Dict[str, Any]] = None,
	api_key: Optional[str] = None
) -> Dict[str, Any]:
	"""
	工作流分析（返回JSON结果）
	
	Args:
		user_prompt: 要分析的内容
		llm_id: LLM模型ID，默认为1
		user: 用户标识
		extra_inputs: 额外输入参数
		api_key: API密钥
		
	Returns:
		解析后的JSON结果字典
	"""
	client = get_workflow_client(api_key=api_key, user=user)
	
	logger.info(f"开始工作流分析, llm_id={llm_id}, 内容长度={len(user_prompt)}")
	
	# 阻塞模式调用
	result = client.run_workflow(
		llm_id=llm_id,
		user_prompt=user_prompt,
		user=user,
		extra_inputs=extra_inputs,
		response_mode="blocking"
	)
	
	# 提取 outputs
	data = result.get("data", {})
	outputs = data.get("outputs", {})
	
	if not outputs:
		logger.warning("工作流分析完成, 但outputs为空")
		logger.debug(f"完整响应: {result}")
		return {"error": "无输出数据", "raw_response": result}
	
	# 如果 outputs 只有一个键，直接返回其值
	if len(outputs) == 1:
		key = list(outputs.keys())[0]
		value = outputs[key]
		# 尝试解析为 JSON
		if isinstance(value, str):
			try:
				parsed = json.loads(value)
				logger.info(f"工作流分析完成, 从outputs解析JSON成功")
				return parsed
			except json.JSONDecodeError:
				pass
		logger.info(f"工作流分析完成, 返回outputs单键值")
		return value if not isinstance(value, str) else {key: value}
	else:
		logger.info(f"工作流分析完成, 返回完整outputs")
		return outputs


def upload_files(
	file_paths: List[Union[str, Path]],
	user: Optional[str] = None,
	api_key: Optional[str] = None,
	continue_on_error: bool = True
) -> List[Dict[str, Any]]:
	"""
	批量上传文件（全局便捷函数）
	
	Args:
		file_paths: 文件路径列表
		user: 用户标识
		api_key: API密钥
		continue_on_error: 遇到错误时是否继续
		
	Returns:
		上传结果列表
	"""
	client = get_workflow_client(api_key=api_key, user=user)
	return client.upload_files(file_paths, user, continue_on_error)


def build_file_inputs(
	variable_name: str,
	file_ids: Optional[List[str]] = None,
	file_paths: Optional[List[Union[str, Path]]] = None,
	document_type: str = "document",
	user: Optional[str] = None,
	api_key: Optional[str] = None,
	auto_upload: bool = True
) -> Dict[str, List[Dict[str, str]]]:
	"""
	构建 workflow 文件输入格式
	
	Args:
		variable_name: workflow 中的变量名
		file_ids: 已上传的文件ID列表
		file_paths: 本地文件路径列表（auto_upload=True时自动上传）
		document_type: 文档类型，如 "document", "image" 等
		user: 用户标识
		api_key: API密钥
		auto_upload: 是否自动上传文件
		
	Returns:
		格式化的 inputs 字典，可直接用于 workflow
		
	Example:
		# 使用已上传的文件ID
		inputs = build_file_inputs("files", file_ids=["file-123", "file-456"])
		
		# 自动上传本地文件
		inputs = build_file_inputs("files", file_paths=["doc1.pdf", "doc2.pdf"])
		
		# 结果格式：
		{
		  "files": [
		    {"transfer_method": "local_file", "upload_file_id": "file-123", "type": "document"},
		    {"transfer_method": "local_file", "upload_file_id": "file-456", "type": "document"}
		  ]
		}
	"""
	ids = file_ids or []
	
	# 自动上传
	if auto_upload and file_paths:
		logger.info(f"build_file_inputs auto_upload count={len(file_paths)}")
		upload_results = upload_files(file_paths, user, api_key, continue_on_error=True)
		
		for result in upload_results:
			if result.get('success'):
				ids.append(result['file_id'])
			else:
				logger.warning(f"build_file_inputs upload_failed file={Path(result.get('file_path')).name}")
		
		if not ids:
			raise RuntimeError("所有文件上传失败")
		
		logger.info(f"build_file_inputs upload_success count={len(ids)}/{len(file_paths)}")
	
	# 构建文件列表
	file_list = []
	for file_id in ids:
		file_list.append({
			"transfer_method": "local_file",
			"upload_file_id": file_id,
			"type": document_type
		})
	
	return {variable_name: file_list}


def analyze_images(
	user_prompt: str,
	image_paths: Optional[List[Union[str, Path]]] = None,
	file_ids: Optional[List[str]] = None,
	llm_id: int = 2,
	user: Optional[str] = None,
	api_key: Optional[str] = None,
	auto_upload: bool = True
) -> Dict[str, Any]:
	"""
	图像分析（workflow 方式，返回JSON结果）
	
	Args:
		user_prompt: 分析提示词
		image_paths: 本地图片路径列表
		file_ids: 已上传的文件ID列表
		llm_id: LLM模型ID，默认为2
		user: 用户标识
		api_key: API密钥
		auto_upload: 是否自动上传文件
		
	Returns:
		解析后的JSON结果字典
		
	Example:
		# 使用本地图片
		result = analyze_images(
			user_prompt="分析这些图片中的内容",
			image_paths=["image1.png", "image2.jpg"]
		)
		
		# 使用已上传的图片ID
		result = analyze_images(
			user_prompt="分析这些图片中的内容",
			file_ids=["file-123", "file-456"]
		)
	"""
	if not image_paths and not file_ids:
		raise ValueError("image_paths 和 file_ids 至少需要提供一个")
	
	# 构建图片输入
	extra_inputs = build_file_inputs(
		variable_name="images",
		file_ids=file_ids,
		file_paths=image_paths,
		document_type="image",
		user=user,
		api_key=api_key,
		auto_upload=auto_upload
	)
	
	client = get_workflow_client(api_key=api_key, user=user)
	
	logger.info(f"开始图像分析, llm_id={llm_id}, 图片数量={len(extra_inputs.get('images', []))}, 提示词长度={len(user_prompt)}")
	
	# 阻塞模式调用
	result = client.run_workflow(
		llm_id=llm_id,
		user_prompt=user_prompt,
		user=user,
		extra_inputs=extra_inputs,
		response_mode="blocking"
	)
	
	# 提取 outputs
	data = result.get("data", {})
	outputs = data.get("outputs", {})
	
	if not outputs:
		logger.warning("图像分析完成, 但outputs为空")
		logger.debug(f"完整响应: {result}")
		return {"error": "无输出数据", "raw_response": result}
	
	# 如果 outputs 只有一个键，直接返回其值
	if len(outputs) == 1:
		key = list(outputs.keys())[0]
		value = outputs[key]
		# 尝试解析为 JSON
		if isinstance(value, str):
			try:
				parsed = json.loads(value)
				logger.info(f"图像分析完成, 从outputs解析JSON成功")
				return parsed
			except json.JSONDecodeError:
				pass
		logger.info(f"图像分析完成, 返回outputs单键值")
		return value if not isinstance(value, str) else {key: value}
	else:
		logger.info(f"图像分析完成, 返回完整outputs")
		return outputs

